<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">

<html><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>adc_internal.pks</title><link rel="stylesheet" type="text/css" href="../../../styles/main.css" /><script type="text/javascript" src="../../../styles/main.js"></script><script type="text/javascript">NDLoader.LoadJS("Content", "../../../styles/");</script></head>

<!-- Generated by Natural Docs, version 2.1.1 -->

<!-- saved from url=(0016)http://localhost -->

<body onload="NDLoader.OnLoad('Content');" class="NDPage NDContentPage">

<a name="ADC_INTERNAL"></a><a name="Topic181"></a><div class="CTopic TClass LSQL first">
 <div class="CTitle">ADC_INTERNAL</div>
 <div class="CBody"><p>Implements a dynamic controller for APEX pages. Internal package, may only be called from package <a href="../../../index.html#File:plugin/packages/adc_plugin.pks:ADC_PLUGIN" target="_top" onmouseover="NDContentPage.OnLinkMouseOver(event,69);" onmouseout="NDContentPage.OnLinkMouseOut(event);" >ADC_PLUGIN</a> and <a href="../../../index.html#File:core/packages/adc_api.pks:ADC_API" target="_top" onmouseover="NDContentPage.OnLinkMouseOver(event,14);" onmouseout="NDContentPage.OnLinkMouseOut(event);" >ADC_API</a>.</p><div class="CHeading">How it works</div><p>When ADC is used to dynamically control an APEX page, it must distinguish two scenarios:</p><ul><li><p>The page is initially rendered</p></li><li><p>A dynamic request must be processed</p></li></ul><div class="CHeading">The page is rendered</div><p>When the page is rendered, ADC must understand which page elements to bind event handlers to.&nbsp; This information can be taken from table ADC_PAGE_ITEMS which is maintained during administration of the page rules. ADC detects &quot;relevant&quot; page items by examining the technical condition of a rule against the APEX data dictionary. If it finds page items which are referenced within the technical condition, those will be marked as relevant.</p><p>Another reason for a page item to become relevant is that it has been set to be initially mandatory or if it was recognized that the page item is a number or date item. In these cases, ADC must assure that mandatory items are automatically checked and values entered in number or date items are valid numbers or dates.</p><p>It must also perform business rules to compute the initial visual state of the page.&nbsp; This is achieved by performing the same steps as explained below for the dynamic request. If the page is rendered, no firing item is known. ADC uses adc_util.C_NO_FIRING_ITEM in this case.</p><div class="CHeading">ADC responses to a dynamic request</div><p>When ADC responds to a dynamic request, the main task is to analyze the actual &quot;page state&quot; The page state is maintained by package ADC_PAGE_STATE. See there for further information on the page state.</p><p>The flow is that all page state values are provided to a decision table that is stored in ADC_RULE_GROUP.DECISION_TABLE for the rule group of the APEX page actually executed. Based on this page state, a rule is selected from the set of rules. If more than one rule matches the page state (a match is reached if the technical condition is true and the triggering element is included in the rule's list of triggering elements), the first rule (i.e. the rule with the lowest sort order) is selected. If no rule matches, nothing happens.&nbsp; When a rule is found, all attached rule actions of that rule are executed in sort order.&nbsp; Each rule action can contain JavaScript snippets and/or PL/SQL code. The PL/SQL code is enriched by the requested parameter values and executed immediately. JavaScript is also enriched, but collected in a JavaScript response stack.</p><p>A PL/SQL block can change the page state of a page element. When this happens, that page element is pushed onto a recursion stack. The recursion stack is maintained in package ADC_RECURSION_STACK.&nbsp; See there for further information on the recursion stack.&nbsp; After processing all rule actions, the recursion stack is examined to find all page elements on the stack. If one is found, it becomes the firing item, and recursively the decision table of the rule group is is executed based on the changed page state, likely resulting in a new rule to be executed.&nbsp; This continues until there is no page element left on the recursion stack. To avoid infinite loops, some restrictive rules apply for the recursion stack. See the documentation of the ADC_RECURSION_STACK package for details.</p><p>Upon completion, the JavaScript answer stack is serialized into a &lt;script&gt; element and passed back to the calling environment.&nbsp; To avoid problems with JavaScript embedded into a JSON document, the JavaScript code is converted to a hex code representation and re-converted client side.&nbsp; When the re-converted script is appended to the page using jQuery, the script is immediately executed. After this, the &lt;script&gt; element is deleted from the page.</p><div class="CHeading">Author</div><p>Juergen Sieben, ConDeS GmbH</p></div>
</div>

<a name="ADC_INTERNAL.Functions"></a><a name="Topic50"></a><div class="CTopic TGroup LSQL">
 <div class="CTitle">Functions</div>
</div>

<a name="ADC_INTERNAL.get_bind_items_as_json"></a><a name="Topic73"></a><div class="CTopic TFunction LSQL">
 <div class="CTitle">get_bind_items_as_json</div>
 <div id="NDPrototype73" class="NDPrototype"><div class="PSection PPlainSection"><span class="SHKeyword">function</span> get_bind_items_as_json</div><div class="PSection PPlainSection"><span class="SHKeyword">return</span> <span class="SHKeyword">clob</span></div></div>
 <div class="CBody"><p>Getter to retrieve all elements that needs to be bound to an event handler as JSON.</p><p>Is called during plugin initialization.&nbsp; The instance contains all relevant elements ADC needs to observe, along with the event it watches.&nbsp; For these items ADC will instantiate an event handler that calls ADC.&nbsp; This method is called from the ADC plugin</p><p>Returns: JSON instance containing name and event of all relevant page items</p></div>
</div>

<a name="ADC_INTERNAL.get_cgr_id"></a><a name="Topic52"></a><div class="CTopic TFunction LSQL">
 <div class="CTitle">get_cgr_id</div>
 <div id="NDPrototype52" class="NDPrototype"><div class="PSection PPlainSection"><span class="SHKeyword">function</span> get_cgr_id</div><div class="PSection PPlainSection"><span class="SHKeyword">return</span> adc_rule_groups.cgr_id<span class="SHKeyword">%type</span></div></div>
 <div class="CBody"><p>Method to retreive the actually processed rule group id</p><div class="CHeading">Returns</div><p>CGR_ID actually in use</p></div>
</div>

<a name="ADC_INTERNAL.get_event"></a><a name="Topic53"></a><div class="CTopic TFunction LSQL">
 <div class="CTitle">get_event</div>
 <div id="NDPrototype53" class="NDPrototype"><div class="PSection PPlainSection"><span class="SHKeyword">function</span> get_event</div><div class="PSection PPlainSection"><span class="SHKeyword">return</span> <span class="SHKeyword">varchar2</span></div></div>
 <div class="CBody"><p>Getter to get the event that was raised.</p><div class="CHeading">Returns</div><p>Name of the event</p></div>
</div>

<a name="ADC_INTERNAL.get_event_data"></a><a name="Topic54"></a><div class="CTopic TFunction LSQL">
 <div class="CTitle">get_event_data</div>
 <div id="NDPrototype54" class="NDPrototype WideForm"><div class="PSection PParameterSection PascalStyle"><table><tr><td class="PBeforeParameters"><span class="SHKeyword">function</span> get_event_data(</td><td class="PParametersParentCell"><table class="PParameters"><tr><td class="PName first">p_key&nbsp;</td><td class="PType last"><span class="SHKeyword">in</span> <span class="SHKeyword">varchar2</span></td></tr></table></td><td class="PAfterParameters">)</td></tr></table></div><div class="PSection PPlainSection"><span class="SHKeyword">return</span> <span class="SHKeyword">varchar2</span></div></div>
 <div class="CBody"><p>Method to retrieve additional event data information such as returned data from a modal dialog.&nbsp; If the event data is a structured JSON, &lt;p_key&gt; is used to extract specific information.&nbsp; IF &lt;p_key&gt; is NULL, the complete answer is returned</p><div class="CHeading">Parameter</div><table class="CDefinitionList"><tr><td class="CDLEntry">p_key<div class="CDLParameterType"><span class="SHKeyword">in</span> <span class="SHKeyword">varchar2</span></div></td><td class="CDLDefinition"><p>Optional key to filter event data</p></td></tr></table><div class="CHeading">Returns</div><p>Event data</p></div>
</div>

<a name="ADC_INTERNAL.get_error_flag"></a><a name="Topic74"></a><div class="CTopic TFunction LSQL">
 <div class="CTitle">get_error_flag</div>
 <div id="NDPrototype74" class="NDPrototype"><div class="PSection PPlainSection"><span class="SHKeyword">function</span> get_error_flag</div><div class="PSection PPlainSection"><span class="SHKeyword">return</span> <span class="SHKeyword">boolean</span></div></div>
 <div class="CBody"><p>Getter to read the error status.</p><div class="CHeading">Returns</div><p>TRUE if the execution of the ADC rule encountered an error, FALSE if not</p></div>
</div>

<a name="ADC_INTERNAL.get_firing_item"></a><a name="Topic75"></a><div class="CTopic TFunction LSQL">
 <div class="CTitle">get_firing_item</div>
 <div id="NDPrototype75" class="NDPrototype"><div class="PSection PPlainSection"><span class="SHKeyword">function</span> get_firing_item</div><div class="PSection PPlainSection"><span class="SHKeyword">return</span> <span class="SHKeyword">varchar2</span></div></div>
 <div class="CBody"><p>Getter to get the name of the firing item. If NULL, adc_util.C_NO_FIRING_ITEM is returned.</p><div class="CHeading">Returns</div><p>Name of the firing item or adc_util.C_NO_FIRING_ITEM if NULL</p></div>
</div>

<a name="ADC_INTERNAL.get_items_to_observe"></a><a name="Topic57"></a><div class="CTopic TFunction LSQL">
 <div class="CTitle">get_items_to_observe</div>
 <div id="NDPrototype57" class="NDPrototype"><div class="PSection PPlainSection"><span class="SHKeyword">function</span> get_items_to_observe</div><div class="PSection PPlainSection"><span class="SHKeyword">return</span> <span class="SHKeyword">varchar2</span></div></div>
 <div class="CBody"><p>Method to retrieve a list of items that need to pass their actual value to ADC although they are not bound to an event handler.</p><p>Is called during plugin initialization.&nbsp; Items which need to pass their actual value but need not be bound by an event handler are registered as observable items.&nbsp; They don't call ADC when they are changed but pass their actual value with every call to ADC raised by other items.&nbsp; This method is called from the ADC plugin</p><div class="CHeading">Returns</div><p>Comma separated list of item selectors to register for observation</p></div>
</div>

<a name="ADC_INTERNAL.get_page_items"></a><a name="Topic76"></a><div class="CTopic TFunction LSQL">
 <div class="CTitle">get_page_items</div>
 <div id="NDPrototype76" class="NDPrototype"><div class="PSection PPlainSection"><span class="SHKeyword">function</span> get_page_items</div><div class="PSection PPlainSection"><span class="SHKeyword">return</span> <span class="SHKeyword">varchar2</span></div></div>
 <div class="CBody"><p>Getter to retrieve a list of elements that potentially have changed during execution of ADC.</p><p>Is used to put together a adc_util.C_DELIMITER delimited list of page items.&nbsp; This method is called from the ADC plugin</p><p>Returns: C_DELIMITER delimited list of page items that potentially have changed</p></div>
</div>

<a name="ADC_INTERNAL.process_request"></a><a name="Topic51"></a><div class="CTopic TFunction LSQL">
 <div class="CTitle">process_request</div>
 <div id="NDPrototype51" class="NDPrototype"><div class="PSection PPlainSection"><span class="SHKeyword">function</span> process_request</div><div class="PSection PPlainSection"><span class="SHKeyword">return</span> <span class="SHKeyword">clob</span></div></div>
 <div class="CBody"><p>Method to process an ADC request.</p><p>Is used to calculate the new status of the page based on the page state values and the underlying ADC rules.</p><div class="CHeading">Flow</div><ul><li><p>Make session state and metadata (firing item, event, event data etc.) available for the decision table (this data is referenced to as the page state)</p></li><li><p>Query decision table (ADC_RULE_GROUPS.CGR_DECISION_TABLE) against the page state</p></li><li><p>If a rule has to be executed, perform all assigned actions:</p><ul><li><p>execute actions PL/SQL code immediately and</p></li><li><p>collect all JavaScript</p></li></ul></li><li><p>If a PL/SQL code changes the page state, recursively check rules to determine whether further rules have to be processed</p></li><li><p>If no further rule has to be processed, return all collected JavaScript snippets within a &lt;script&gt; element</p></li></ul><p>This method is called from the ADC plugin</p><div class="CHeading">Returns</div><p>JavaScript code in response to the request</p></div>
</div>

<a name="ADC_INTERNAL.read_settings"></a><a name="Topic79"></a><div class="CTopic TFunction LSQL last">
 <div class="CTitle">read_settings</div>
 <div id="NDPrototype79" class="NDPrototype WideForm"><div class="PSection PParameterSection PascalStyle"><table><tr><td class="PBeforeParameters"><span class="SHKeyword">procedure</span> read_settings(</td><td class="PParametersParentCell"><table class="PParameters"><tr><td class="PName first">p_firing_item&nbsp;</td><td class="PType last"><span class="SHKeyword">in</span> <span class="SHKeyword">varchar2</span>,</td></tr><tr><td class="PName first">p_event&nbsp;</td><td class="PType last"><span class="SHKeyword">in</span> <span class="SHKeyword">varchar2</span>,</td></tr><tr><td class="PName first">p_event_data&nbsp;</td><td class="PType last"><span class="SHKeyword">in</span> <span class="SHKeyword">varchar2</span></td></tr></table></td><td class="PAfterParameters">)</td></tr></table></div></div>
 <div class="CBody"><p>Helper to copy plugin settings to an internal record G_PARAM.</p><p>Is called before the actual rule action takes place (at the beginning of render and AJAX methods) to copy the plugin parameters and status to a package record.</p><p>This method is called from the ADC plugin. Published separately to allow for the plugin to call PROCESS_INITIALIZATION_CODE if required before calling PROCESS_REQUEST.</p><div class="CHeading">Parameters</div><table class="CDefinitionList"><tr><td class="CDLEntry">p_firing_item<div class="CDLParameterType"><span class="SHKeyword">in</span> <span class="SHKeyword">varchar2</span></div></td><td class="CDLDefinition"><p>Firing item</p></td></tr><tr><td class="CDLEntry">p_event<div class="CDLParameterType"><span class="SHKeyword">in</span> <span class="SHKeyword">varchar2</span></div></td><td class="CDLDefinition"><p>Firing event</p></td></tr><tr><td class="CDLEntry">p_event_data<div class="CDLParameterType"><span class="SHKeyword">in</span> <span class="SHKeyword">varchar2</span></div></td><td class="CDLDefinition"><p>Additional event information</p></td></tr></table></div>
</div>

</body></html>